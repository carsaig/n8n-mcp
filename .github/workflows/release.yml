name: Release (ARM64) to GHCR + Coolify

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'docs/**'
      - 'docker-compose.coolify.yml'
  workflow_dispatch:
    inputs:
      version:
        description: "Version tag (e.g., v2.11.4). Leave empty to auto bump patch."
        required: false
        type: string
      release_notes:
        description: "Custom release notes (optional). Overrides auto-generated notes."
        required: false
        type: string
      trigger_coolify:
        description: "Trigger Coolify deployment after publish"
        required: false
        type: boolean
        default: true

permissions:
  contents: write
  packages: write
  pull-requests: write
  issues: write

concurrency:
  group: release
  cancel-in-progress: true

env:
  IMAGE_NAME: ghcr.io/carsaig/n8n-mcp
  COOLIFY_WEBHOOK_URL: https://coolify.certain.cc/api/v1/deploy?uuid=z8s00c0kgo0s8848400c88kw&force=true
  UPSTREAM_OWNER: czlonkowski
  UPSTREAM_REPO: n8n-mcp

jobs:
  release:
    runs-on: [self-hosted, Linux, ARM64]
    permissions:
      contents: read
      packages: write

    outputs:
      version: ${{ steps.version.outputs.version }}
      is_custom: ${{ steps.version.outputs.is_custom }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version tag (auto bump or manual input)
        id: version
        shell: bash
        env:
          VERSION_INPUT: ${{ inputs.version }}
        run: |
          set -euo pipefail

          # If this workflow was triggered by a tag push, respect that tag verbatim
          if [[ "${GITHUB_REF:-}" =~ ^refs/tags/ ]]; then
            NEXT="${GITHUB_REF#refs/tags/}"
          elif [[ -n "${VERSION_INPUT:-}" ]]; then
            # Accept vX.Y.Z or vX.Y.Z-cs.N
            if [[ ! "$VERSION_INPUT" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-cs\.[0-9]+)?$ ]]; then
              echo "Invalid version tag format: ${VERSION_INPUT}. Expected vMAJOR.MINOR.PATCH or vMAJOR.MINOR.PATCH-cs.N" >&2
              exit 1
            fi
            NEXT="$VERSION_INPUT"
          else
            # Query upstream repo for the authoritative latest release tag
            # No auth header — public repo, and GITHUB_TOKEN is scoped to this repo only
            UPSTREAM_TAG=$(curl -sSL \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${UPSTREAM_OWNER}/${UPSTREAM_REPO}/releases/latest" \
              | jq -r '.tag_name')

            if [[ -z "$UPSTREAM_TAG" || "$UPSTREAM_TAG" == "null" ]]; then
              echo "::error::Failed to fetch upstream release tag from ${UPSTREAM_OWNER}/${UPSTREAM_REPO}"
              exit 1
            fi
            echo "Upstream latest release: ${UPSTREAM_TAG}"

            # Get our latest local tag
            LATEST=$(git tag -l 'v*' --sort=-v:refname | head -n1 || true)
            echo "Latest local tag: ${LATEST:-<none>}"

            if [[ -z "$LATEST" ]]; then
              # First release ever — adopt upstream version
              NEXT="$UPSTREAM_TAG"
            elif [[ "$LATEST" == "$UPSTREAM_TAG" ]]; then
              # We already released this exact upstream version — custom patch
              NEXT="${UPSTREAM_TAG}-cs.1"
            elif [[ "$LATEST" =~ ^${UPSTREAM_TAG}-cs\.([0-9]+)$ ]]; then
              # Already have custom patches on this upstream base — increment
              NEXT="${UPSTREAM_TAG}-cs.$(( ${BASH_REMATCH[1]} + 1 ))"
            else
              # Latest local tag is for a different upstream version — adopt the new one
              NEXT="$UPSTREAM_TAG"
            fi
          fi
          # Determine if this is a custom build (has -cs. suffix)
          if [[ "$NEXT" == *-cs.* ]]; then
            IS_CUSTOM=true
          else
            IS_CUSTOM=false
          fi
          echo "Resolved version: ${NEXT} (custom_build=${IS_CUSTOM})"
          echo "VERSION=${NEXT}" | tee -a "$GITHUB_ENV"
          echo "version=${NEXT}" >> "$GITHUB_OUTPUT"
          echo "is_custom=${IS_CUSTOM}" >> "$GITHUB_OUTPUT"


      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GHCR_PAT }}


      - name: Re-tag upstream image (no custom changes)
        if: steps.version.outputs.is_custom == 'false'
        run: |
          set -euo pipefail
          # Upstream uses tags without 'v' prefix (e.g. 2.35.2)
          UPSTREAM_DOCKER_TAG="${VERSION#v}"
          UPSTREAM_IMAGE="ghcr.io/${UPSTREAM_OWNER}/${UPSTREAM_REPO}:${UPSTREAM_DOCKER_TAG}"
          echo "Re-tagging upstream image ${UPSTREAM_IMAGE} → ${IMAGE_NAME}:${VERSION}"
          docker buildx imagetools create \
            --tag "${IMAGE_NAME}:${VERSION}" \
            --tag "${IMAGE_NAME}:latest" \
            "${UPSTREAM_IMAGE}"

      - name: Build and push (ARM64 — custom changes only)
        if: steps.version.outputs.is_custom == 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          push: true
          no-cache: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}

      - name: Echo image tag
        run: |
          echo "Image: ${IMAGE_NAME}:${VERSION}"
          echo "Custom build: ${{ steps.version.outputs.is_custom }}"

  release_and_deploy:
    runs-on: ubuntu-latest
    needs: release
    if: ${{ needs.release.result == 'success' }}
    permissions:
      contents: write
      packages: write
      deployments: write
      pull-requests: write
      issues: write
    steps:
      - name: Create GitHub Release (auto or custom notes)
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.release.outputs.version }}
          generate_release_notes: ${{ inputs.release_notes == '' }}
          body: ${{ inputs.release_notes }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout repository for compose bump
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Bump docker-compose.coolify image tag
        id: bump_compose
        shell: bash
        run: |
          set -euo pipefail
          FILE="docker-compose.coolify.yml"
          if [[ ! -f "$FILE" ]]; then
            echo "No $FILE present; skipping compose bump" >&2
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          VER="${{ needs.release.outputs.version }}"
          # Replace the image tag line
          sed -E -i "s#^(\s*image:\s*ghcr\.io/carsaig/n8n-mcp:).*#\1${VER}#" "$FILE"
          if git diff --quiet -- "$FILE"; then
            echo "No changes to $FILE (already at $VER)"
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "Will bump $FILE to $VER"
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Bump docs references to image tag
        id: bump_docs
        shell: bash
        run: |
          set -euo pipefail
          VER="${{ needs.release.outputs.version }}"
          # Only touch references to the carsaig image
          CHANGED=0
          if compgen -G "docs/**/*.md" > /dev/null; then
            # Replace ghcr.io/carsaig/n8n-mcp:<anything> with new ${VER}
            find docs -type f -name "*.md" -print0 | xargs -0 sed -E -i "s#(ghcr\\.io/carsaig/n8n-mcp:)[^\`\"\)\s]+#\\1${VER}#g"
            if ! git diff --quiet -- docs; then CHANGED=1; fi
          fi
          echo "changed=${CHANGED}" >> "$GITHUB_OUTPUT"

      - name: Generate release notes file in docs/custom_builds
        id: gen_notes
        shell: bash
        run: |
          set -euo pipefail
          VER="${{ needs.release.outputs.version }}"
          mkdir -p docs/custom_builds
          # Filename uses dots for cs suffix: vX.Y.Z-cs.N -> release_vX.Y.Z.cs.N.md
          FN="docs/custom_builds/release_${VER/-cs\./.cs.}.md"
          if [[ -f "$FN" ]]; then
            echo "Release notes already exist: $FN"
            echo "changed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          # Find previous tag for diff range
          PREV_TAG=$(git tag -l 'v*' --sort=-v:refname | grep -v "^${VER}$" | head -n1 || true)
          PREV_TAG="${PREV_TAG:-HEAD~10}"
          {
            echo "# Release ${VER}"
            echo
            echo "Date: $(date -u +'%Y-%m-%d')"
            echo
            echo "## Summary"
            echo "- Automated release notes generated by workflow."
            echo
            echo "## Changes since ${PREV_TAG}"
            echo '```'
            git log --pretty=format:'%h %s' --no-merges "${PREV_TAG}..HEAD" || true
            echo '```'
            echo
            echo "## Container images"
            echo "- ghcr.io/carsaig/n8n-mcp:${VER}"
            echo "- ghcr.io/carsaig/n8n-mcp:latest"
          } > "$FN"
          if git add "$FN" && git diff --cached --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Open PR to update compose, docs, and release notes
        if: steps.bump_compose.outputs.changed == 'true' || steps.bump_docs.outputs.changed == '1' || steps.gen_notes.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GHCR_PAT }}
          branch: chore/compose-docs-bump-${{ needs.release.outputs.version }}
          title: "chore: bump compose/docs and add release notes for ${{ needs.release.outputs.version }}"
          commit-message: "chore: compose/docs bump and release notes for ${{ needs.release.outputs.version }}"
          body: |
            This PR updates:
            - docker-compose.coolify.yml → image tag `${{ needs.release.outputs.version }}` (if changed)
            - docs/** → references to `ghcr.io/carsaig/n8n-mcp:<tag>` bumped to `${{ needs.release.outputs.version }}` (if changed)
            - docs/custom_builds/release_*.md → auto-generated release notes (new file)

            Merge this PR so Coolify deployments and docs stay in sync with the published image and each release is documented.
          add-paths: |
            docker-compose.coolify.yml
            docs/**
            docs/custom_builds/**
          labels: |
            deployment
            documentation

      - name: Start GitHub Deployment
        if: ${{ needs.release.result == 'success' && needs.release.outputs.version != '' && (github.event_name != 'workflow_dispatch' || inputs.trigger_coolify) }}
        id: gh_deploy_start
        uses: bobheadxi/deployments@v1
        with:
          step: start
          token: ${{ secrets.GITHUB_TOKEN }}
          env: Coolify
          ref: ${{ github.sha }}

      - name: Load secrets from 1Password
        if: ${{ needs.release.result == 'success' && needs.release.outputs.version != '' && (github.event_name != 'workflow_dispatch' || inputs.trigger_coolify) }}
        uses: 1password/load-secrets-action@v2
        with:
          export-env: true
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          COOLIFY_API_KEY: "op://SECRETS/Coolify/API_Token"

      - name: Trigger Coolify Deploy (by UUID)
        if: ${{ needs.release.result == 'success' && needs.release.outputs.version != '' && (github.event_name != 'workflow_dispatch' || inputs.trigger_coolify) }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Invoking Coolify webhook: $COOLIFY_WEBHOOK_URL"
          HTTP_CODE=$(curl -s -o /tmp/coolify_resp.json -w "%{http_code}" -X POST \
            -H "Authorization: Bearer ${COOLIFY_API_KEY}" \
            "$COOLIFY_WEBHOOK_URL")
          echo "Coolify HTTP: ${HTTP_CODE}"
          echo "Coolify response body:" && cat /tmp/coolify_resp.json || true
          if [[ "${HTTP_CODE}" -lt 200 || "${HTTP_CODE}" -ge 300 ]]; then
            echo "Coolify webhook failed with HTTP ${HTTP_CODE}" >&2
            exit 1
          fi

      - name: Mark deployment success
        if: ${{ (github.event_name != 'workflow_dispatch' || inputs.trigger_coolify) && success() && steps.gh_deploy_start.outcome == 'success' }}
        uses: bobheadxi/deployments@v1
        with:
          step: finish
          token: ${{ secrets.GITHUB_TOKEN }}
          env: Coolify
          status: success
          deployment_id: ${{ steps.gh_deploy_start.outputs.deployment_id }}

      - name: Mark deployment failure
        if: ${{ (github.event_name != 'workflow_dispatch' || inputs.trigger_coolify) && failure() && steps.gh_deploy_start.outcome == 'success' }}
        uses: bobheadxi/deployments@v1
        with:
          step: finish
          token: ${{ secrets.GITHUB_TOKEN }}
          env: Coolify
          status: failure
          deployment_id: ${{ steps.gh_deploy_start.outputs.deployment_id }}
